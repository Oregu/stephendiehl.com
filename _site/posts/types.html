<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
<head>

    <!-- Basic Page Needs
  ================================================== -->
    <meta charset="utf-8">
    <title>Haskell Types for Python Programmers ( Part 1 )</title>
    <meta name="description" content="{{description}}">
    <meta name="author" content="{{author}}">

    <!-- Mobile Specific Metas
  ================================================== -->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!-- CSS
  ================================================== -->
    <link rel="stylesheet" href="../css/base.css">
    <link rel="stylesheet" href="../css/skeleton.css">
    <link rel="stylesheet" href="../css/typography.css">
    <link rel="stylesheet" href="../css/layout.css">
    <link rel="stylesheet" href="../css/syntax.css">
    <link rel="stylesheet" href="../css/custom.css">

    <link href="http://fonts.googleapis.com/css?family=Droid+Sans:400,700|Droid+Serif:400,400italic|Inconsolata" rel="stylesheet">
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$','$'], ['\\(','\\)'] ],
          // Needs to escaped for Pandoc
          displayMath: [ ["\\[","\\]"] ],
          processEscapes: true
        },
        "HTML-CSS": { availableFonts: ["TeX"] }
      });
    </script>

    <!--[if lt IE 9]>
        <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Favicons
    ================================================== -->
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">

</head>
<body>

<div style="display:none">
\def\reflect#1{{#1}^\dagger}
\def\inverse#1{{#1}^{-1}}
\def\dual#1{{#1}^{\rm op}}
\def\identgen#1#2{I^{#1}_{#2}}
\def\arrow{\rightarrow}
\def\arrowsub#1{\yyarrowa{_{#1}}}
\def\arrowsuper#1{\yyarrowa{^{#1}}}
\def\arrowsubsuper#1#2{\yyarrowa{_{#1}^{#2}}}
\(\newcommand{\cat}[1]{\mathcal{#1}}\)
\(\newcommand{\ob}[1]{\mathrm{ob}(#1)}\)
\(\newcommand{\hom}[1]{\mathrm{hom}(#1)}\)
\(\newcommand{\id}[1]{\text{id}_{#1}}\)
\(\newcommand{\C}{\mathcal{C}}\)
\(\newcommand{\D}{\mathcal{D}}\)

\(\newcommand{\dom}[1]{\text{dom}(#1)}\)
\(\newcommand{\cod}[1]{\text{cod}(#1)}\)
</div>

    <!-- Primary Page Layout
    ================================================== -->

    <div class="container">
        <div class="three columns sidebar">
            <nav>
                <h3 id="logo">Stephen Diehl</h3>
                <ul>
                    <li><a href="../">Index</a></li>
                    <li><a href="../pages/slides.html">Talks</a></li>
                    <li><a href="../posts.html">Writings</a></li>
                    <li><a href="../pages/projects.html">Projects</a></li>
                    <li><a href="../pages/hire.html">Contact Me</a></li>
                    <li><a href="../pages/pgp.html">PGP Key</a></li>
                    <li><a href="https://github.com/sdiehl">Github</a></li>
                    <li><a href="https://twitter.com/#!/smdiehl">Twitter</a></li>
                </ul>
            </nav>
             
        </div>

        <div class="twelve columns offset-by-one content">
            <h4 id="haskell-types-for-python-programmers-part-1">Haskell Types for Python Programmers ( Part 1 )</h4>
<p>This is a three part blog about how to think about some of the core ideas of Haskell in the everyday language of Python of programmers.</p>
<ul>
<li>Part 1. Constrained genericity vs dynamic typing</li>
<li>Part 2. Parametric polymorphism vs objects and subtyping</li>
<li>Part 3. Category theory vs design patterns</li>
</ul>
<h4 id="introduction">Introduction</h4>
<p>In Haskell all functions have two definitions.</p>
<p>A <strong>value level</strong> definition:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">and</span> p q <span class="fu">=</span> p <span class="fu">&amp;&amp;</span> q </code></pre>
<p>And a <strong>type level</strong> definition, often called the type signature:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">and</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></code></pre>
<p>A type signature may contain concrete types such as</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Bool</span>
<span class="dt">Int</span>
<span class="dt">Double</span>
<span class="dt">Float</span>
<span class="dt">Char</span>
<span class="dt">String</span></code></pre>
<p>Or free paramaters ( type variables ) which hold the place for concrete types. These are most often lower case letters starting at the beginning of the alphabet in the order they appear in the signature.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">a
b
x0
x1</code></pre>
<p>A signature <code>a -&gt; a</code> is a function of one argument returning a value of the same type as the argument.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">addOne x <span class="fu">=</span> x<span class="dv">+1</span></code></pre>
<p>A rough equivelant in Python would be.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> addOne(x):
    <span class="kw">return</span> x<span class="dv">+1</span></code></pre>
<p>A signature <code>a -&gt; a -&gt; a</code> is a function of two arguments<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> of the same type, returning a value of the same as both the arguments.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">add x y <span class="fu">=</span> x<span class="fu">+</span>y</code></pre>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> add(x,y):
    <span class="kw">return</span> x+y</code></pre>
<p>In general the <code>(-&gt;)</code> operation is right associative, i.e. ( <code>a -&gt; b -&gt; c = a -&gt; ( b -&gt; c )</code>.</p>
<h4 id="currying">Currying</h4>
<p>In Python functions arguments can be represented by tuples. For example the add function:</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; add = <span class="kw">lambda</span> x,y: x+y
&gt;&gt;&gt; args = (<span class="dv">1</span>,<span class="dv">2</span>)
&gt;&gt;&gt; add(*args)</code></pre>
<p>If we were to split the tuple of arguments into two lambda expression we’d have a function which allowed application of arguments one at a time:</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; add = <span class="kw">lambda</span> x: <span class="kw">lambda</span> y: x+y
&gt;&gt;&gt; addOne = add(<span class="dv">1</span>)
&lt;function &lt;<span class="kw">lambda</span>&gt; at <span class="bn">0x7fe2ba959b90</span>&gt;
&gt;&gt;&gt; addOne(<span class="dv">2</span>)
<span class="dv">3</span></code></pre>
<p>Evaluation in Haskell is quite different from Python in that arguments are explicitly not tuples. Unless explictly indicated Haskell functions are curried functions each of a single argument.</p>
<p>The standard library also defines two important functions for coercing between single arguments of tuples and curried functions.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">curry</span><span class="ot"> ::</span> ((a,b)<span class="ot">-&gt;</span>c) <span class="ot">-&gt;</span> a<span class="ot">-&gt;</span>b<span class="ot">-&gt;</span>c
<span class="fu">curry</span> f a b <span class="fu">=</span> f (a,b)
 
<span class="fu">uncurry</span><span class="ot"> ::</span> (a<span class="ot">-&gt;</span>b<span class="ot">-&gt;</span>c) <span class="ot">-&gt;</span> ((a,b)<span class="ot">-&gt;</span>c)
<span class="fu">uncurry</span> f (a,b)<span class="fu">=</span> f a b</code></pre>
<p>For example:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Single tuple argument </span>
<span class="fu">fst</span> (a,b) <span class="fu">=</span> a
<span class="co">-- Multiple argument</span>
root a b <span class="fu">=</span> (b <span class="fu">+</span> <span class="fu">sqrt</span>(b<span class="fu">^</span><span class="dv">2-4</span>))<span class="fu">/</span>(<span class="dv">2</span><span class="fu">*</span>a)</code></pre>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co"># (a,b) -&gt; a</span>
<span class="kw">def</span> fst(tup):
    a,b = tup
    <span class="kw">return</span> a

<span class="co"># Int -&gt; Int -&gt; Int</span>
<span class="kw">def</span> root(a, b):
    <span class="kw">return</span> (b + sqrt(b^<span class="dv">2-4</span>))/(<span class="dv">2</span>*a)</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">curry</span><span class="ot"> fst ::</span> c <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c
<span class="fu">uncurry</span><span class="ot"> root ::</span> (c, c) <span class="ot">-&gt;</span> c</code></pre>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co"># a -&gt; b -&gt; a</span>
<span class="kw">def</span> curry_fst(a):
    <span class="kw">def</span> _curry_fst(b):
        <span class="kw">return</span> a
    <span class="kw">return</span> _curry_fst

<span class="co"># Int -&gt; Int -&gt; Int</span>
<span class="kw">def</span> curry_root(a):
    <span class="kw">def</span> _curry_root(b):
        <span class="kw">return</span> (b + sqrt(b^<span class="dv">2-4</span>))/(<span class="dv">2</span>*a)
    <span class="kw">return</span> _curry_root


<span class="co"># (Int, Int) -&gt; Int</span>
<span class="kw">def</span> uncurry_root(tup):
    a,b = tup
    <span class="kw">return</span> (b + sqrt(b^<span class="dv">2-4</span>))/(<span class="dv">2</span>*a)</code></pre>
<h4 id="constraints">Constraints</h4>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> a <span class="ot">-&gt;</span> a
addOne x <span class="fu">=</span> x<span class="dv">+1</span></code></pre>
<p>Notice in both the Haskell and the Python examples above we wrote the body of function as an addition but nowhere in our type signature did we specify that our input values need be numeric quantities capable of being added. The task is known as <strong>constrained genericity</strong>.</p>
<p>Both languages have to handle the case that addition is not defined for non-numeric quantities. In Python there is fundamentally no type distinction between numeric quantities and objects which overload numeric methods such as <code>__add__</code> magic method.</p>
<p>In Haskell however, the compiler will keep the free parameter preserving the polymorphism we want, but will attach a constraint on the free parameter <code>a</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">addOne ::</span> <span class="kw">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</code></pre>
<p>This would read as “A function which takes value of type <code>a</code> and returns a value of the same type and the input type is an instance of the <code>Num</code> typeclass”.</p>
<p>So, what is a typeclass you ask? Simply put it is a set of functions or operators which are implemented over a type.</p>
<p>The <strong>class definition</strong> defines the abstract signature of all instances of the type class. The following would read “Num defines an operation which over a type a which takes two arguments also of type a and returns the same type a”.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Num</span> a <span class="kw">where</span>
<span class="ot">    (+) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</code></pre>
<p>If we dig into the Haskell standard library, sure enough we find a type class definition which defines how to add two Int objects.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span>  <span class="kw">Num</span> <span class="dt">Int</span>  <span class="kw">where</span>
    (<span class="fu">+</span>) x y <span class="fu">=</span> plusInt x y</code></pre>
<p>The <code>plusInt</code> function is a C function which performs unboxed integer multiplication and returns a boxed integer.</p>
<p>Python would “handle” this problem by attempting to call <code>__add__</code> or <code>__radd__</code> on the operands, and if methods are not defined throws an Exception at <strong>runtime</strong>.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Foo(<span class="dt">object</span>):
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, x):
        <span class="ot">self</span>.val = x
    
&gt;&gt;&gt; Foo(<span class="dv">1</span>) + Foo(<span class="dv">1</span>)
Traceback (most recent call last):
  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, in &lt;module&gt;
<span class="ot">TypeError</span>: unsupported operand <span class="dt">type</span>(s) <span class="kw">for</span> +: <span class="st">'object'</span> and <span class="st">'object'</span></code></pre>
<p>Haskell rejects this at <strong>compile time</strong>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- fail.hs</span>
<span class="kw">data</span> <span class="dt">Foo</span> <span class="fu">=</span> <span class="dt">Foo</span>
main <span class="fu">=</span> addOne <span class="dt">Foo</span></code></pre>
<pre class="sourceCode bash"><code class="sourceCode bash">$ ghc fail.hs
[1 of 1] Compiling Main             <span class="kw">(</span> fail.hs, fail.o <span class="kw">)</span>

    No instance <span class="kw">for</span> <span class="kw">(</span>Num Foo<span class="kw">)</span>
      arising from a use of <span class="kw">`</span>addOne<span class="st">'</span>
<span class="st">    Possible fix: add an instance declaration for (Num Foo)</span></code></pre>
<p>In short, Python’s notion of duck typing and <strong>ad-hoc polymorphism</strong> with constraints in Haskell are quite similar from a structural standpoint, but with the exception that Python is not able to reason about types in question and defers failures to runtime since it is not able to reason about the types of arguments while Haskell is able to reject a large class of invalid programs at compile time.</p>
<p>To remedy the Python program, we make the Foo class quack like a integer.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Foo(<span class="dt">object</span>):
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, x):
        <span class="ot">self</span>.val = x
        
    <span class="kw">def</span> <span class="ot">__add__</span>(<span class="ot">self</span>, other):
        <span class="kw">return</span> Foo(<span class="ot">self</span>.x + other.x)

&gt;&gt;&gt; Foo(<span class="dv">1</span>) + Foo(<span class="dv">1</span>)
Foo(<span class="dv">2</span>)</code></pre>
<p>In Haskell, we define a <code>Num</code> instance declaration.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="kw">data</span> <span class="dt">Foo</span> a <span class="fu">=</span> <span class="dt">Foo</span> a

<span class="kw">instance</span> <span class="kw">Num</span> <span class="dt">Foo</span> <span class="kw">where</span>
    (<span class="dt">Foo</span> x) <span class="fu">+</span> (<span class="dt">Foo</span> y) <span class="fu">=</span> <span class="dt">Foo</span> (x <span class="fu">+</span> y)

<span class="fu">&gt;&gt;&gt;</span> <span class="dt">Foo</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dt">Foo</span> <span class="dv">1</span>
<span class="dt">Foo</span> <span class="dv">2</span></code></pre>
<h4 id="higher-functions">Higher Functions</h4>
<p>It could be argued that core idea of functional programming is composition<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup>. Namely the composition of higher functions, and in typed functional languages; the constrained composition of functions.</p>
<p>For types for to be useful for functional progrmaming we require that we be able to compose functions with other functions while maintaining expressivity and type safety. For example we would like to write down a generic function which takes a “object with some structure” and apply a function over the internal structure.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> <span class="dt">map</span>(f, xs):
    <span class="kw">return</span> (f(x) <span class="kw">for</span> x in xs)</code></pre>
<p>If we expand the iterator sugar out a bit we find more illuminating definition:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co"># (object -&gt; object) -&gt; iterable -&gt; iterable</span>
<span class="kw">def</span> <span class="dt">map</span>(f, xs):
    <span class="kw">return</span> <span class="dt">iter</span>(f(x) <span class="kw">for</span> x in xs.<span class="ot">__iter__</span>())</code></pre>
<p>Notice that in Python we have two qualitatively different classes of “things” in the signature: objects and iterables of objects.</p>
<p>If we mentally translate our word “iterable” to “functor”<sup><a href="#fn3" class="footnoteRef" id="fnref3">3</a></sup> in Haskell we might describe the input function as <code>a -&gt; b</code> over types <code>a</code> and <code>b</code> over a functor on a ( <code>f a</code> ) to a functor on b (<code>f b</code> ).</p>
<p>In this case we have two categories of types in the signature a’s and b’s. When multiple type variables occur in the signature we call them <code>rigid</code>. Type variables that are not rigid are free.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">fmap</span><span class="ot"> ::</span> <span class="kw">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre>
<p>The type <code>f a</code> represents a type constructor of with one type parameter a. The signature of the type we call the <strong>kind</strong>. The kind of the a simple type is <code>*</code>. The kind of a unary type is <code>* -&gt; *</code> or a type over a type, for example the “type of list of type integers”.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ: <span class="fu">:</span>kind <span class="dt">Int</span>
<span class="dt">Int</span><span class="ot"> ::</span> <span class="fu">*</span> 

λ: <span class="fu">:</span>kind []
[]<span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span></code></pre>
<p>For example let’s inspect some simple type instances in the GHCI shell and the magic commands <code>:kind</code> and <code>:type</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ: <span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a
λ: <span class="fu">:</span>kind <span class="dt">List</span>
<span class="dt">List</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>

λ: <span class="kw">data</span> <span class="dt">Either</span> a b <span class="fu">=</span> <span class="kw">Left</span> a <span class="fu">|</span> <span class="kw">Right</span> b
<span class="dt">Either</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Notice the free parameters</span>
λ: <span class="fu">:</span><span class="kw">type</span> <span class="kw">Left</span> <span class="kw">True</span>
<span class="kw">Left</span> <span class="kw">False</span><span class="ot"> ::</span> <span class="dt">Either</span> <span class="dt">Bool</span> b

λ: <span class="fu">:</span><span class="kw">type</span> <span class="kw">Right</span> <span class="dv">3</span>
<span class="kw">Left</span> <span class="kw">False</span><span class="ot"> ::</span> <span class="dt">Either</span> a <span class="dt">Int</span></code></pre>
<h4 id="section"></h4>
<p>Of course we still want to preserve polymorphism over parameters, so we might ask how do we spell out maps over structures without having to define each and every instance of lists. In this case, in our definition we only specialize one of the type parameters, namely <code>f</code> to be the List type.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="kw">instance</span> <span class="kw">Functor</span> <span class="dt">List</span> <span class="kw">where</span>

<span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> b

    <span class="fu">fmap</span> f (<span class="dt">Cons</span> x) <span class="fu">=</span> <span class="dt">Cons</span> (f x)
    <span class="fu">fmap</span> f <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nil</span></code></pre>
<p>The type in the constructor of a is still rigid within the functor defintion. Therefore for lists of all types ( including lists of lists ) we get fmap definitions for free, simply by substitution of one of the rigid type variables in our parametric type signature.</p>
<h4 id="further-reading">Further Reading:</h4>
<ul>
<li><a href="http://www.cs.cornell.edu/andru/papers/where-clauses.pdf">Subtypes vs. Where Clauses: Constraining Parametric Polymorphism</a></li>
<li><a href="http://www.haskellforall.com/2012/08/the-category-design-pattern.html">The Category Pattern</a></li>
<li><a href="http://www.haskell.org/haskellwiki/Haskell_Tutorial_for_C_Programmers">Haskell for C Programmers</a></li>
<li><a href="http://learnyouahaskell.com/making-our-own-types-and-typeclasses">Making Our Own Types and Typeclasses</a></li>
</ul>
<div class="footnotes">
<hr></hr>
<ol>
<li id="fn1"><p>See the discussion of currying later.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Along with the rejection of mutable state and implicit effects.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>The name comes from category theory where functors are mappings between categories that preserve aspects of the <a href="http://ncatlab.org/nlab/show/functor">specific notions of structure of the category</a>.<a href="#fnref3">↩</a></p></li>
</ol>
</div>
        </div>
    </div>

    <!-- JS
    ================================================== -->
    <script src="http://code.jquery.com/jquery-1.7.1.min.js"></script>

<!-- End Document
================================================== -->
</body>
