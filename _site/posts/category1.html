<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
<head>

    <!-- Basic Page Needs
  ================================================== -->
    <meta charset="utf-8">
    <title>Categorical Programming: Introduction</title>
    <meta name="description" content="{{description}}">
    <meta name="author" content="{{author}}">

    <!-- Mobile Specific Metas
  ================================================== -->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!-- CSS
  ================================================== -->
    <link rel="stylesheet" href="../css/base.css">
    <link rel="stylesheet" href="../css/skeleton.css">
    <link rel="stylesheet" href="../css/typography.css">
    <link rel="stylesheet" href="../css/layout.css">
    <link rel="stylesheet" href="../css/syntax.css">
    <link rel="stylesheet" href="../css/custom.css">

    <link href="http://fonts.googleapis.com/css?family=Droid+Sans:400,700|Droid+Serif:400,400italic|Inconsolata" rel="stylesheet">
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$','$'], ['\\(','\\)'] ],
          // Needs to escaped for Pandoc
          displayMath: [ ["\\[","\\]"] ],
          processEscapes: true
        },
        "HTML-CSS": { availableFonts: ["TeX"] },

        TeX: {
            Macros: {
                cat : ["\\mathcal{#1}", 1],
                ob  : ["\\mathrm{ob}(#1)", 1],
                hom : ["\\mathrm{hom}(#1)", 1],
                id  : ["\\text{id}_{#1}", 1],
                C   : "\\mathcal{C}",
                D   : "\\mathcal{D}",

                iso    : "{\cong}\)",
                Hask   : "{\cat{Hask}}\)",
                yoneda : "{\mathcal{Y}}\)",

                dom: ["{\text{dom}(#1)}\)", 1],
                cod: ["{\text{cod}(#1)}\)", 1],
            }
        }
      });
    </script>

    <!--[if lt IE 9]>
        <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Favicons
    ================================================== -->
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">

</head>
<body>

<div style="display:none">
<p>Category Theory Definitions for Haskell Programmers</p>
</div>

    <!-- Primary Page Layout
    ================================================== -->

    <div class="container">
        <div class="three columns sidebar">
            <nav>
                <h3 id="logo">Stephen Diehl</h3>
                <ul>
                    <li><a href="../">Index</a></li>
                    <li><a href="../pages/slides.html">Talks</a></li>
                    <li><a href="../posts.html">Writings</a></li>
                    <li><a href="../pages/projects.html">Projects</a></li>
                    <li><a href="../pages/hire.html">Contact Me</a></li>
                    <li><a href="../pages/pgp.html">PGP Key</a></li>
                    <li><a href="https://github.com/sdiehl">Github</a></li>
                    <li><a href="https://twitter.com/#!/smdiehl">Twitter</a></li>
                </ul>
            </nav>
             
        </div>

        <div class="twelve columns offset-by-one content">
            <h3 id="forward">Forward</h3>
<p>Categorical programming is a style of programming that uses high-level concepts from mathematics as design patterns for organising, abstracting and structuring logic with the end goal of having well-defined definitions and a rigorous system for reasoning about both the type and value semantics of a program.</p>
<p>This tutorial is a humble attempt to provide a bridge between the dense literature and an easy introduction to category theory for Haskell programmers.</p>
<p>This series can also be thought as surface reading of the brilliant <a href="http://hackage.haskell.org/package/categories">categories library on Hackage</a> and many examples are drawn from it.</p>
<h3 id="categories">Categories</h3>
<p>A <strong>category</strong> $ \C $ is a construction with four definitions:</p>
<ol style="list-style-type: decimal">
<li>A collection of <strong>objects</strong>. Written $ \text{ob}(\C) $.</li>
</ol>
<p><img src="../images/objects.svg" alt="Illustration"></img>.</p>
<ol start="2" style="list-style-type: decimal">
<li>A collection of <strong>morphisms</strong>. Written $ \text{hom}(\C) $.</li>
</ol>
<p><img src="../images/morphisms.svg" alt="Illustration"></img>.</p>
<ol start="3" style="list-style-type: decimal">
<li><p>A <strong>composition</strong> operation $ ( \circ ) $ or written in Haskell as $ ( . ) $. The composition of morphsism yields morphisms in $ \C $.</p>
<p>\[ ( f . g ) \]</p>
<p>\[ ( f \circ g ) \]</p></li>
</ol>
<p><img src="../images/composition2.svg" alt="Illustration"></img>.</p>
<ol start="4" style="list-style-type: decimal">
<li><p>For each object $ A $ there is an <strong>identity</strong> morphism .</p>
<p>\[ \text{id}_A \]</p></li>
</ol>
<p><img src="../images/identity.svg" alt="Illustration"></img>.</p>
<h4 id="category-of-haskell-types">Category of Haskell types</h4>
<p>In Haskell we’re constantly dealing with categorical structures. In fact they’re baked the very foundations of the language translate, and a large part of Haskell can be cast nicely into categorical terms. We call this category <strong>HASK</strong>.</p>
<table>
<th>
Category Theory
</th>
<th>
Haskell
</th>
<th>
Examples
</th>
<tr>
    <td>
Objects
</td>
    <td>
Haskell Types
</td>
    <td>

<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Int</span>
<span class="dt">Bool</span>
<span class="dt">String</span>
<span class="dt">Tuple</span></code></pre>
</td>
</tr>

<tr>
    <td>
Morphisms
</td>
    <td>
Haskell Functions
</td>
    <td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">head</span><span class="ot"> ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="fu">map</span><span class="ot"> ::</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</code></pre>
</td>
</tr>

<tr>
    <td>
Composition
</td>
    <td>
Function Composition
</td>
    <td>

<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</code></pre>
</td>
</tr>
</table>

<p>The set of all non-polymorphic Haskell types forms a category with Haskell functions as morphisms. For example:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">head</span><span class="ot"> ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="fu">head</span> (x<span class="fu">:</span>_) <span class="fu">=</span>  x

<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">head</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="fu">=</span> <span class="dv">1</span></code></pre>
<p><br /> The Haskell prelude also contains a function composition operator which should be familiar to all.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c
g <span class="fu">.</span> f <span class="fu">=</span>  \x <span class="ot">-&gt;</span> g (f x)</code></pre>
<p><br /> And similarly a polymorphic identity function.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">id</span><span class="ot"> ::</span> forall a<span class="fu">.</span> a <span class="ot">-&gt;</span> a
<span class="fu">id</span> x <span class="fu">=</span>  x</code></pre>
<p><br /> Like most statically typed languages Haskell enforces types in composition.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">B</span>
<span class="ot">g ::</span> <span class="dt">B</span> <span class="ot">-&gt;</span> <span class="dt">C</span>

g <span class="fu">.</span><span class="ot"> f ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">C</span></code></pre>
<h4 id="homsets">Homsets</h4>
<p>A category is constructed out a collection of morphisms, over objects in the categotry. The collection of other morphisms in a category is called a <strong>homset</strong> and written as:</p>
<p>\[ \hom{\C} \]</p>
<p>A individual a morphism $ f $ has two associated values, its <strong>domain</strong> $ \text{dom}(f) $ and <strong>codomain</strong> $ \text{cod}(f) $.</p>
<p>Elements in the homset are morphisms between objects in $ \C $, namely if $ A,B \in \ob{\C} $ then the set of morphisms in $ \C $ between $ A $ and $ B $ is written:</p>
<p>\[ \hom{A,B} \]</p>
<p>For composition to be well defined we require that composition itself be a mapping only defined for:</p>
<p>\[ ( \circ ) : \hom{B,C} \rightarrow \hom{A,B} \rightarrow \hom{A,C} \]</p>
<h4 id="formal-definition-of-categories">Formal Definition of Categories</h4>
<p>I will use the following tabular format for the definition of categories from here out. The first column is the type of construction, the second column is the constraints on the objects involved in the definition, and the third column is the definition of the construction.</p>
<table>
<th>
<strong>Category</strong>
</th>
<tr>
    <td>
Objects
</td>
    <td> 
\[ X, Y \in \C \]
</td>
    <td></td>
</tr>

<tr>
    <td>
Morphisms
</td>
    <td> 
\[ f \in \hom{\C} \]
</td>
    <td> 
\[ f: X \rightarrow Y \]
</td>
</tr>

<tr>
    <td>
Composition
</td>
    <td>
    
\[ 
        f : X \rightarrow Y \\
        g : Y \rightarrow Z  
    \]
</td>
    <td> 
\[ g . f : X \rightarrow Z \]
</td>
</tr>

<tr>
    <td>
Identities
</td>
    <td> 
\[ \text{For all } X \in \C \]
</td>
    <td> 
\[ \text{id}_A : X \rightarrow X \]
</td>
</tr>

</table>


<p><img src="../images/composition.svg" alt="Illustration"></img>.</p>
<p>The corresponding definition table for a category is that of the laws for the category.</p>
<table>
<th>
<strong>Category Laws</strong>
</th>
<tr>
    <td> 
Identity
</td>
    <td> 
\[ 
        A \in \C \\
        f : A \rightarrow B
    \]
</td>
    <td> 
\[ f . \text{id}_A  = \text{id}_B . f = f \]
</td>
</tr>
<tr>
    <td> 
Associativity
</td>
    <td> 
\[ f,g,h \in \hom{\C} \]
</td>
    <td> 
\[ ( h . g ) . f = h . ( g . f ) \]
</td>
</tr>
</table>

<p><img src="../images/category_law_1.svg" alt="Illustration"></img>.</p>
<p><img src="../images/category_law_2.svg" alt="Illustration"></img>.</p>
<p>In textbooks these diagrams are often written in the common diagramatic form:</p>
<p><img src="../images/category_alt_law_1.svg" alt="Illustration"></img>.</p>
<p><img src="../images/category_alt_law_2.svg" alt="Illustration"></img>.</p>
<h4 id="set">SET</h4>
<p>Categories are often written in bold. For example the category <strong>SET</strong> is often a motivating topic of discussion since classical set theoretic definitions are often generalized.</p>
<table>
<th>
<strong>Set</strong>
</th>
<tr>
    <td>
Objects
</td>
    <td>
Set: $ S $
</td>
    <td>
……………………
</td>
</tr>

<tr>
    <td>
Morphisms
</td>
    <td>
Total functions over $ S $
</td>
    <td>
……………………
</td>
</tr>

<tr>
    <td>
Composition
</td>
    <td> 
\[ 
        f : A \rightarrow B \\ 
        g : B \rightarrow C 
    \]
</td>
    <td> 
\[ 
        g \circ f : A \rightarrow C \\
        g \circ f = \lambda a. g (f a) 
    \]
</td>
</tr>

<tr>
    <td>
Identities
</td>
    <td> 
\[ A \in S \]
</td>
    <td> 
    
\[
        \text{id}_A :: A \rightarrow A \\
        \text{id}_A = \lambda x . x
    \]
</td>
</tr>

</table>

<p>With the usual properties:</p>
<table>
<th>
<strong>Set</strong>
</th>
<tr>
    <td> 
Associativity
</td>
    <td> 
$ ( f \circ g ) \circ h = f \circ ( g \circ h ) $
</td>
</tr>

<tr>
    <td> 
Identities
</td>
    <td> 
$ \text{id}_B \circ f = f \circ \text{id}_A = f $
</td>
</tr>

</table>


<p>If we define a toy <code>Cat</code> typeclass with the above definition and define an instance for Haskell (-&gt;) from <code>GHC.Prim</code> we have:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Hask</span> <span class="fu">=</span> (<span class="ot">-&gt;</span>)

<span class="kw">class</span> <span class="dt">Cat</span> cat <span class="kw">where</span>
<span class="ot">    ident ::</span> cat a a
<span class="ot">    comp  ::</span> cat b c <span class="ot">-&gt;</span> cat a b <span class="ot">-&gt;</span> cat a c

<span class="kw">instance</span> <span class="dt">Cat</span> <span class="dt">Hask</span> <span class="kw">where</span>
    ident x  <span class="fu">=</span> x
    comp f g <span class="fu">=</span> \x <span class="ot">-&gt;</span> f (g x)</code></pre>
<p>We see that we of course recover the identitiy function and compostion from the Prelude.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Cat</span> <span class="dt">Hask</span> <span class="kw">where</span>
    ident <span class="fu">=</span> <span class="fu">id</span>
    comp  <span class="fu">=</span> (<span class="fu">.</span>)

<span class="co">-- Equivalent definition from Control.Category</span>

<span class="kw">instance</span> <span class="dt">Category</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span>
    <span class="fu">id</span> <span class="fu">=</span> Prelude.id
    (<span class="fu">.</span>) <span class="fu">=</span> (<span class="fu">Prelude..</span>)</code></pre>
<p>It is worth noting the common confusion that morphisms are not functions. It is the other way around, in the category SET functions are morphisms with objects as sets but this is a special case. In general morphisms are a pure abstraction which have structural similarity to functions.</p>
<h4 id="classes-of-categories">Classes of categories</h4>
<p>There are three classes of categories that are studied:</p>
<ul>
<li><p><strong>Concrete categories</strong> - Model mathematical structures with structure-preserving mappings between objects. Examples: ( <strong>Vec</strong> )</p></li>
<li><p><strong>Real world categories</strong> - Model real world systems such as type systems and physical processes. Examples: ( <strong>Hask</strong> )</p></li>
<li><p><strong>Abstract categories</strong> - Categories studied for relationship to other categories or motivating the discussion of the large scale structure of mathematics. Examples: ( <strong>Cat</strong> )</p></li>
</ul>
<p><br /> Four out purposes we’ll discuss a small set of <strong>concrete categories</strong> that don’t require much knowledge of abstract algebra.</p>
<p>THe notion of a <strong>subcategory</strong> is also important, it is a category contained within another category which also satisfies the category construction.</p>
<p>It is are illuminating to look at the trivial categories , namely categories with small amounts of objects and morphisms to gain a general understanding of their structure even though they are not of much practical interest.</p>
<p>There are also some simple categories, the simplest being the <strong>Zero</strong> category, which is the category with no objects and no morphisms.</p>
<table>
<th>
<strong>Zero</strong>
</th>
<tr>
    <td>
Objects
</td>
    <td> </td>
    <td> 
\[ \emptyset \]
</td>
</tr>

<tr>
    <td>
Morphisms
</td>
    <td> </td>
    <td> 
\[ \emptyset \]
</td>
</tr>

<tr>
    <td>
Composition
</td>
    <td> 
*
</td>
    <td> 
*
</td>
</tr>

<tr>
    <td>
Identities
</td>
    <td> 
\[ \text{For all } A \]
</td>
    <td> 
\[ \text{id}_A : A \rightarrow A \]
</td>
</tr>

</table>

<p>The category laws are vacuously true for this category.</p>
<p>A slightly more interesting ( only slightly! ) is the <strong>One</strong> category.</p>
<p><img src="../images/one.svg" alt="Illustration"></img>.</p>
<table>
<th>
<strong>One</strong>
</th>
<tr>
    <td>
Objects
</td>
    <td> 
singleton set
</td>
    <td> 
\[ {X} \]
</td>
</tr>

<tr>
    <td>
Morphisms
</td>
    <td> </td>
    <td> 
\[ f : X \rightarrow X \]
</td>
</tr>

<tr>
    <td>
Composition
</td>
    <td> </td>
    <td> 
\[ (f . f) = \text{id}_X \]
</td>
</tr>

<tr>
    <td>
Identities
</td>
    <td> 
\[ \text{For all } A \]
</td>
    <td>
    
\[ 
        \text{id}_X : X \rightarrow X  \\
        \text{id}_X = \lambda x. X
    \]
</td>
</tr>

</table>

<p>Since the only morphism in the category is also the identity all the laws hold merely by substitution.</p>
<p>It is also trivially true that <strong>Zero</strong> is a subcategory of <strong>One</strong>.</p>
<table>
<th>
<strong>Two</strong>
</th>
<tr>
    <td>
Objects
</td>
    <td> 
\[ {X,Y} \]
</td>
</tr>

<tr>
    <td>
Morphisms
</td>
    <td> </td>
    <td> 
    
\[
    f : X \rightarrow X \\
    g : Y \rightarrow Y
    \]
</td>
</tr>

<tr>
    <td>
Composition
</td>
    <td> </td>
    <td> 
\[ (f . f) = \text{id}_X \]
</td>
</tr>

<tr>
    <td>
Identities
</td>
    <td> 
\[ \text{For all } A \]
</td>
    <td>
    
\[ 
        \text{id}_X : X \rightarrow X  \\
        \text{id}_X = \lambda x. X \\
        \text{id}_Y : Y \rightarrow Y  \\
        \text{id}_Y = \lambda x. X
    \]
</td>
</tr>

</table>

<p><img src="../images/two.svg" alt="Illustration"></img>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>

<span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (<span class="fu">id</span>, (<span class="fu">.</span>))
<span class="kw">import</span> <span class="dt">Control.Category</span>

<span class="kw">data</span> <span class="dt">Zero</span> a b <span class="kw">where</span>
    <span class="dt">Idz</span><span class="ot"> ::</span> <span class="dt">Zero</span> () ()

<span class="kw">data</span> <span class="dt">One</span> a b <span class="kw">where</span>
    <span class="dt">Ida</span><span class="ot"> ::</span> <span class="dt">One</span> a ()


<span class="kw">instance</span> <span class="dt">Category</span> <span class="dt">Zero</span> <span class="kw">where</span>
    <span class="fu">id</span> <span class="fu">=</span> <span class="dt">Idz</span>
    <span class="dt">Idz</span> <span class="fu">.</span> <span class="dt">Idz</span> <span class="fu">=</span> <span class="dt">Idz</span>

<span class="kw">instance</span> <span class="dt">Category</span> <span class="dt">One</span> <span class="kw">where</span>
    <span class="fu">id</span> <span class="fu">=</span> <span class="dt">Ida</span>
    <span class="dt">Ida</span> <span class="fu">.</span> <span class="dt">Ida</span> <span class="fu">=</span> <span class="dt">Ida</span></code></pre>
<h4 id="discrete-categories">Discrete Categories</h4>
<p>Discrete categories are categories where the only morphisms are identity morphisms.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>

<span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (<span class="fu">id</span>, (<span class="fu">.</span>))
<span class="kw">import</span> <span class="dt">Control.Category</span>

<span class="kw">data</span> <span class="dt">Discrete</span> n n <span class="kw">where</span>
    <span class="dt">Auto</span><span class="ot"> ::</span> <span class="dt">Discrete</span> n n

<span class="kw">instance</span> <span class="dt">Category</span> <span class="dt">Discrete</span> <span class="kw">where</span>
    <span class="fu">id</span> <span class="fu">=</span> <span class="dt">Auto</span>
    <span class="dt">Auto</span> <span class="fu">.</span> <span class="dt">Auto</span> <span class="fu">=</span> <span class="dt">Auto</span></code></pre>
<p>In a discrete category it follows that if there exists a morphisms between objects $ A $ and $ B $ then $ A $ must equal $ B $. Discrete categories are often indexed by the cardinality of the number of singleton objects in the category.</p>
<h4 id="algebraic-categories">Algebraic Categories</h4>
<p>From algebra there are several examples of categories. For example vector spaces over the real field.</p>
<table>
<th>
<strong>Vec</strong>
</th>
<tr>
    <td>
Objects
</td>
    <td>
Vector spaces
</td>
</tr>

<tr>
    <td>
Morphisms
</td>
    <td>
Linear mappings
</td>
</tr>

<tr>
    <td>
Composition
</td>
    <td>
Composition of linear mappings
</td>
</tr>

<tr>
    <td>
Identities
</td>
    <td></td>
</tr>
</table>



<table>
<th>
<strong>Grp</strong>
</th>
<tr>
    <td>
Objects
</td>
    <td>
Groups
</td>
</tr>

<tr>
    <td>
Morphisms
</td>
    <td>
Group homomorphisms
</td>
</tr>

<tr>
    <td>
Composition
</td>
    <td>
Composition of group homomorphsisms
</td>
</tr>

<tr>
    <td>
Identities
</td>
    <td> 
Identity mappings
</td>
</tr>
</table>

<table>
<th>
<strong>Mon</strong>
</th>
<tr>
    <td>
Objects
</td>
    <td>
Monoids
</td>
</tr>

<tr>
    <td>
Morphisms
</td>
    <td>
Monoid homomorphisms
</td>
</tr>

<tr>
    <td>
Composition
</td>
    <td>
Composition of monoid homomorphsisms
</td>
</tr>

<tr>
    <td>
Identities
</td>
    <td>
Identity mappings
</td>
</tr>
</table>

<p>For example considering the Monoid type of Haskell string types we find that this gives rise to a subcategory of <strong>Hask</strong>. Consider the type definition for Monoid.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monoid</span> a <span class="kw">where</span>
<span class="ot">  mempty ::</span> a
<span class="ot">  mappend ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">  mconcat ::</span> [a] <span class="ot">-&gt;</span> a</code></pre>
<p>The instance for String types is:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">String</span> <span class="fu">=</span> [<span class="dt">Char</span>]

<span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">String</span> <span class="kw">where</span>
        mempty  <span class="fu">=</span> []
        mappend <span class="fu">=</span> (<span class="fu">++</span>)</code></pre>
<table>
<th>
<strong>Str</strong>
</th>
<tr>
    <td>
Objects
</td>
    <td>
Characters
</td>
    <td>
<code>Char</code>
</tr>

<tr>
    <td>
Morphisms
</td>
    <td>
Strings
</td>
    <td>
<code>[Char]</code>
</td>
</tr>

<tr>
    <td>
Composition
</td>
    <td>
String concatention
</td>
    <td>
<code>(++)</code>
</td>
</tr>

<tr>
    <td>
Identities
</td>
    <td>
Empty string
</td>
    <td>
<code>&quot;&quot;</code>
</td>
</tr>
</table>

<p>It is easy to show that the identity laws hold.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">a <span class="fu">++</span> <span class="st">&quot;&quot;</span>  <span class="fu">=</span> <span class="st">&quot;&quot;</span> <span class="fu">++</span> a <span class="fu">==</span> a</code></pre>
<p>Concatetention is a linear mapping so it is also easy to show that composition laws must also hold for all characters.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(a <span class="fu">++</span> b) <span class="fu">++</span> c <span class="fu">=</span> a <span class="fu">++</span> (b <span class="fu">++</span> c)</code></pre>
<p>In short we epxect order-independent append operations. For example:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="st">&quot;foo&quot;</span> <span class="fu">++</span> <span class="st">&quot;bar&quot;</span> <span class="fu">+</span> <span class="st">&quot;&quot;</span> <span class="fu">++</span> <span class="st">&quot;baz&quot;</span> <span class="fu">==</span> <span class="st">&quot;foobarbaz&quot;</span>
<span class="st">&quot;foo&quot;</span> <span class="fu">++</span> <span class="st">&quot;bar&quot;</span> <span class="fu">++</span> <span class="st">&quot;baz&quot;</span>      <span class="fu">==</span> <span class="st">&quot;foobarbaz&quot;</span>
<span class="st">&quot;foo&quot;</span> <span class="fu">++</span> (<span class="st">&quot;bar&quot;</span> <span class="fu">++</span> <span class="st">&quot;baz&quot;</span>)    <span class="fu">==</span> <span class="st">&quot;foobarbaz&quot;</span>
(<span class="st">&quot;foo&quot;</span> <span class="fu">++</span> <span class="st">&quot;bar&quot;</span>) <span class="fu">++</span> <span class="st">&quot;baz&quot;</span>    <span class="fu">==</span> <span class="st">&quot;foobarbaz&quot;</span></code></pre>
<h4 id="some-more-categories">Some More Categories</h4>
<h4 id="logic">Logic</h4>
<p>Deductive logic also forms an important category with propositions as objects and proof trees as morphisms between objects.</p>
<table>
<th>
Deductive Logic ( <strong>Prf</strong> )
<th>
<tr>
    <td>
Objects
</td>
    <td>
Propositions
</td>
    <td>
$ \alpha,\beta,\gamma $
</td>
</tr>

<tr>
    <td>
Morphisms
</td>
    <td>
Proofs
</td>
    <td>
$ \alpha \vdash \beta $
</td>
</tr>

<tr>
    <td>
Composition
</td>
    <td>
Proof Trees
</td>
    <td>
\[
    \frac{\alpha \vdash \beta \hspace{1em} \beta \vdash \gamma}{\alpha \vdash \gamma} 
    \]
</td>
</tr>

<tr>
    <td>
Identities
</td>
    <td>
Tautologies
</td>
    <td>
\[
    \frac{}{\alpha \vdash \alpha} 
    \]
</td>
</tr>
</table>

<h4 id="duality">Duality</h4>
<p>The important results of category is the notion of <strong>duality</strong>. Simply put for any theorem about a category $ \C $ we can obtain a new theorem by swapping domain and codomain of each morphism and changing the argument order of composition we obtain a result that also holds over in category $ \C^\text{op} $ referred to the <strong>dual theorem</strong>.</p>
<ol style="list-style-type: decimal">
<li>Objects of $ \C^\text{op} $ are identical to $ \C $.</li>
<li>Morphisms of the form $ f : B \rightarrow A $ in $ \C^\text{op} $ are the morphisms $ f : A \rightarrow B $ in $ \C $.</li>
<li>Compositions of the form $ g \circ f $ in $ \C^\text{op} $ are of the form $ f \circ g $ in $ \C $.</li>
<li>Identities in $ \C^\text{op} $ are the same as in $ \C $.</li>
</ol>
<p>We can build dual categories in Haskell from categories</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeOperators #-}</span>

<span class="kw">data</span> <span class="dt">Op</span> k a b <span class="fu">=</span> <span class="dt">Op</span> {<span class="ot"> unOp ::</span> k b a }

<span class="kw">instance</span> <span class="dt">Category</span> k <span class="ot">=&gt;</span> <span class="dt">Category</span> (<span class="dt">Op</span> k) <span class="kw">where</span>
  <span class="fu">id</span> <span class="fu">=</span> <span class="dt">Op</span> <span class="fu">id</span>
  (<span class="dt">Op</span> f) <span class="fu">.</span> (<span class="dt">Op</span> g) <span class="fu">=</span> <span class="dt">Op</span> (g <span class="fu">.</span> f)</code></pre>
<h4 id="terminal-and-initial">Terminal and Initial</h4>
<p>Many categories have a special elements or classes of elements where morphisms between objects are uniquely identified. For example a the case where all objects in the category have a single morphism between a single element, such an element is called <strong>initial</strong>. For an initial object $ I \in \text{obj}(\C) $ to be initial we have:</p>
<p>\[
\forall A \in \ob{\C} \hspace{1em} | \text{hom}(0, A) | = 1
\]</p>
<p>This is often written as an arrow with an excalamation point to indicate a unique morphism.</p>
<p>\[
0 \xrightarrow{\hspace{1em}!\hspace{1em}} A.
\]</p>
<p><img src="../images/initial.svg" alt="Illustration"></img>.</p>
<p>The dual notion is that of a <strong>terminal</strong> element $ 1 \in \ob{\C} $.</p>
<p>\[
\forall A \in \ob{\C}  \hspace{1em} | \text{hom}(A, 1) | = 1
\]</p>
<p>\[
A \xrightarrow{\hspace{1em}!\hspace{1em}} 1.
\]</p>
<p><img src="../images/final.svg" alt="Illustration"></img>.</p>
<p>Initial and terminal objects are unique up to isomorphism. For example in the category <strong>Set</strong> the initial element is the null set while the terminal element is the singleton set collapsing any set to a singleton set.</p>
<p>\[
\begin{align}
x &amp;\xrightarrow{\hspace{1em}!\hspace{1em}} \{x\} \\
\{\} &amp;\xrightarrow{\hspace{1em}!\hspace{1em}} x
\end{align}
\]</p>
<p>In the category <strong>One</strong> the terminal object is also the initial object, such a category is said to have a <strong>zero object</strong>.</p>
<p>In the category of vector spaces <strong>Vec</strong> the zero object is the zero dimensional vector space.</p>
<p>The subject of whether <strong>Hask</strong> has initial and terminal objects is a hairy issue that divides the implementation of Haskell language from the category theoretic interpretation of Haskell. Although the definitions below satisfy the requirements it is possible to find counter examples in the Haskell runtime that would break the neccessary properties. See the <a href="http://hackage.haskell.org/package/void">void package</a> for more details.</p>
<p><strong>Initial</strong></p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Void</span> <span class="fu">=</span> <span class="dt">Void</span> <span class="dt">Void</span>

<span class="ot">absurd ::</span> <span class="dt">Void</span> <span class="ot">-&gt;</span> a
absurd (<span class="dt">Void</span> a) <span class="fu">=</span> absurd a</code></pre>
<p><strong>Terminal</strong></p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> () <span class="fu">=</span> ()	

<span class="ot">term ::</span> forall a<span class="fu">.</span> a <span class="ot">-&gt;</span> ()
term _ <span class="fu">=</span> ()	</code></pre>
<p>The <a href="https://github.com/ekmett/categories/tree/master/Control/Category">category</a> library defines this notation using fairly exotic type structures but this concept can be modeled in Haskell’s type system!</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Category</span> k <span class="ot">=&gt;</span> <span class="dt">HasTerminalObject</span> k <span class="kw">where</span>
    <span class="kw">type</span> <span class="dt">Terminal</span><span class="ot"> k ::</span> <span class="fu">*</span>
<span class="ot">    terminate ::</span> a <span class="ot">`k`</span> <span class="dt">Terminal</span> k

<span class="kw">class</span> <span class="dt">Category</span> k <span class="ot">=&gt;</span> <span class="dt">HasInitialObject</span> k <span class="kw">where</span>
    <span class="kw">type</span> <span class="dt">Initial</span><span class="ot"> k ::</span> <span class="fu">*</span>
<span class="ot">    initiate ::</span> <span class="dt">Initial</span> k <span class="ot">`k`</span> a</code></pre>
        </div>
    </div>

    <!-- JS
    ================================================== -->
    <script src="http://code.jquery.com/jquery-1.7.1.min.js"></script>

<!-- End Document
================================================== -->
</body>
