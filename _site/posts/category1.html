<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
<head>

    <!-- Basic Page Needs
  ================================================== -->
    <meta charset="utf-8">
    <title>Categorical Programming: Introduction</title>
    <meta name="description" content="{{description}}">
    <meta name="author" content="{{author}}">

    <!-- Mobile Specific Metas
  ================================================== -->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!-- CSS
  ================================================== -->
    <link rel="stylesheet" href="../css/base.css">
    <link rel="stylesheet" href="../css/skeleton.css">
    <link rel="stylesheet" href="../css/typography.css">
    <link rel="stylesheet" href="../css/layout.css">
    <link rel="stylesheet" href="../css/syntax.css">
    <link rel="stylesheet" href="../css/custom.css">

    <link href="http://fonts.googleapis.com/css?family=Droid+Sans:400,700|Droid+Serif:400,400italic|Inconsolata" rel="stylesheet">
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$','$'], ['\\(','\\)'] ],
          // Needs to escaped for Pandoc
          displayMath: [ ["\\[","\\]"] ],
          processEscapes: true
        },
        "HTML-CSS": { availableFonts: ["TeX"] }
      });
    </script>

    <!--[if lt IE 9]>
        <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Favicons
    ================================================== -->
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">

</head>
<body>

    <!-- Primary Page Layout
    ================================================== -->

    <div class="container">
        <div class="three columns sidebar">
            <nav>
                <h3 id="logo">Stephen Diehl</h3>
                <ul>
                    <li><a href="../">Index</a></li>
                    <li><a href="../posts.html">Writings</a></li>
                    <li><a href="../pages/projects.html">Projects</a></li>
                    <li><a href="../pages/hire.html">Hire Me</a></li>
                    <li><a href="../pages/pgp.html">PGP Key</a></li>
                    <li><a href="https://github.com/sdiehl">Github</a></li>
                    <li><a href="https://twitter.com/#!/smdiehl">Twitter</a></li>
                </ul>
            </nav>
             
        </div>

        <div class="twelve columns offset-by-one content">
            <h3 id="forward">Forward</h3>
<p>This is a multipart blog post on the structure of the mathematical field of Category theory and how it relates to real world programming.</p>
<p>Category theory distills the essence of a large variety of constructions in traditional set theory to more abstract context which can be used to reason about general concepts in computer science and mathematics.</p>
<p>If one were to try and describe the essence of category theory, it is that it is study of relationships between between mappings of elements, but at a level of generality where there is no notion of individual elements. Instead elements arise only out of their relationships between each other.</p>
<p>This tutorial is a humble attempt to provide a bridge between the mathematical literature and the everyday language of the working Haskell programming programmer. Any and all feedback is welcome!</p>
<h3 id="categories">Categories</h3>
<p>A <strong>category</strong> $ C $ is a construction with three things:</p>
<ol style="list-style-type: decimal">
<li>A collection of <strong>objects</strong>.</li>
<li>A collection of <strong>morphisms</strong>.</li>
<li><p>A <strong>composition</strong> operation (.) which given two other morphisms yields a <em>composite morphism</em> denoted</p>
<p>\[ ( f . g ) \]</p></li>
<li><p>For each object $ A $ there is an identity morphism</p>
<p>\[ \text{id}_A \]</p></li>
</ol>
<p>Unlike most discussions, I’m going to stop the mathematical discussion right here and go straight to code so as to not scare the math-phobic Haskell programmer away!</p>
<h4 id="category-of-haskell-types">Category of Haskell types</h4>
<p>In Haskell we’re constantly dealing with categorical structures. In fact they’re baked the very foundations of the language translate, and a large part of Haskell can be cast nicely into categorical terms. We call this category <strong>HASK</strong>.</p>
<table>
<th>
Category Theory
</th>
<th>
Haskell
</th>
<th>
Examples
</th>
<tr>
    <td>
Objects
</td>
    <td>
Haskell Types
</td>
    <td>

<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Int</span>
<span class="dt">Bool</span>
<span class="dt">String</span>
<span class="dt">Tuple</span></code></pre>
</td>
</tr>

<tr>
    <td>
Morphisms
</td>
    <td>
Haskell Functions
</td>
    <td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">head</span><span class="ot"> ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="fu">map</span><span class="ot"> ::</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</code></pre>
</td>
</tr>

<tr>
    <td>
Composition
</td>
    <td>
Function Composition
</td>
    <td>

<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</code></pre>
</td>
</tr>
</table>

<p>The set of all non-polymorphic Haskell types forms a category with Haskell functions as morphisms. For example:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">head</span><span class="ot"> ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="fu">head</span> (x<span class="fu">:</span>_) <span class="fu">=</span>  x

<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">head</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="fu">=</span> <span class="dv">1</span></code></pre>
<p><br /> The Haskell prelude also contains a function composition operator which should be familiar to all.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c
f <span class="fu">.</span> g <span class="fu">=</span>  \ x <span class="ot">-&gt;</span> f (g x)</code></pre>
<p><br /> And similarly a polymorphic identity function.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">id</span><span class="ot"> ::</span> forall a<span class="fu">.</span> a <span class="ot">-&gt;</span> a
<span class="fu">id</span> x <span class="fu">=</span>  x</code></pre>
<p><br /> Like most statically typed languages Haskell enforces types in composition. Namely:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">B</span>
<span class="ot">g ::</span> <span class="dt">B</span> <span class="ot">-&gt;</span> <span class="dt">C</span>

f <span class="fu">.</span><span class="ot"> g ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">C</span></code></pre>
<p><br /> This notion finds a direct analogue in the categorical definition of homsets.</p>
<h4 id="homsets">Homsets</h4>
<p>A category is constructed out a collection of morphisms, a morphism has two associated values, its domain $ \text{dom} $ and codomain $ \text{cod} $. The collection of other morphisms in the category with the same values is called a <strong>homset</strong> as written $ \text{Hom}(A,B) $.</p>
<p>Given a specific category $ C $, we refer to the set of all morphisms in the category as the homset over C \[ \text{Hom}_C \] with:</p>
<p>\[ (A \rightarrow B) \in \text{Hom}(A,B) \]</p>
<p>For composition to be well defined we require that composition itself be a mapping only defined for:</p>
<p>\[ (.) : \text{Hom}(A,B) \rightarrow \text{Hom}(B,C) \rightarrow \text{Hom}(A,C) \]</p>
<p>Haskell programmers should be familiar with this notion of “aligning types”.</p>
<p>It is important to note that this definition is intentionally abstract. While in some concrete categories morphisms are functions in the traditional sense, in general homsets are merely abstract collections of 2-tuples with some abstract binary compostion operation subject to some constraints.</p>
<p>There is some ambiguity in the way that functional programmers and category theorists compose morphisms. Most category theorists would reverse the arguments to get composition as.</p>
<p>\[ (.) : \text{Hom}(B,C) \rightarrow \text{Hom}(A,B) \rightarrow \text{Hom}(A,C) \]</p>
<p>This can lend itself to some confusion and I will try to adopt the functional programmers notation wherever possible.</p>
<h4 id="formal-definition-of-categories">Formal Definition of Categories</h4>
<p>I will use the following tabular format for the definition of categories from here out. The first column is the type of construction, the second column is the constraints on the objects involved in the definition, and the third column is the definition of the construction.</p>
<table>
<th>
Category
</th>
<tr>
    <td>
Objects
</td>
    <td> 
\[ X, Y \in C \]
</td>
    <td></td>
</tr>

<tr>
    <td>
Morphisms
</td>
    <td> 
\[ f \in \text{Hom}_C \]
</td>
    <td> 
\[ f: X \rightarrow Y \]
</td>
</tr>

<tr>
    <td>
Composition
</td>
    <td>
    
\[ 
        f : X \rightarrow Y \\
        g : Y \rightarrow Z  
    \]
</td>
    <td> 
\[ f . g : X \rightarrow Z \]
</td>
</tr>

<tr>
    <td>
Identities
</td>
    <td> 
\[ \text{For all } X \in C \]
</td>
    <td> 
\[ \text{id}_A : X \rightarrow X \]
</td>
</tr>

</table>

<p>The corresponding definition table for a category is that of the laws for the category.</p>
<table>
<th>
Category Laws
</th>
<tr>
    <td> 
Associativity
</td>
    <td> 
\[ f,g,h \in \text{Hom}_C \]
</td>
    <td> 
\[ ( f . g ) . h = f . ( g . h ) \]
</td>
</tr>
<tr>
    <td> 
Identity
</td>
    <td> 
\[ 
        A \in C \\
        f : A \rightarrow B
    \]
</td>
    <td> 
\[ f . \text{id}_A  = \text{id}_B . f = f \]
</td>
</tr>
</table>


<p><img src="../images/category1.svg" alt="Illustration"></img>.</p>
<h4 id="set">SET</h4>
<p>Categories are often written in bold. For example the category <strong>SET</strong> is often a motivating topic of discussion since classical set theoretic definitions are often generalized.</p>
<table>
<th>
<strong>Set</strong>
</th>
<tr>
    <td>
Objects
</td>
    <td>
Set: $ S $
</td>
</tr>

<tr>
    <td>
Morphisms
</td>
    <td>
Total functions over $ S $
</td>
    <td>
………………………
</td>
</tr>

<tr>
    <td>
Composition
</td>
    <td> 
\[ 
        f : B \rightarrow C \\ 
        g : A \rightarrow B 
    \]
</td>
    <td> 
\[ 
        f \circ g : A \rightarrow C \\
        f \circ g = \lambda x. f (g a) 
    \]
</td>
</tr>

<tr>
    <td>
Identities
</td>
    <td> 
\[ A \in S \]
</td>
    <td> 
    
\[
        \text{id}_A :: A \rightarrow A \\
        \text{id}_A = \lambda x . x
    \]
</td>
</tr>

</table>

<p>With the usual properties:</p>
<table>
<th>
<strong>Set</strong>
</th>
<tr>
    <td> 
Associativity
</td>
    <td> 
$ ( f \circ g ) \circ h = f \circ ( g \circ h ) $
</td>
</tr>

<tr>
    <td> 
Identities
</td>
    <td> 
$ f \circ \text{id}_A = \text{id}_A \circ f = f $
</td>
</tr>

</table>

<p>If we define a toy <code>Cat</code> typeclass with the above definition and define an instance for Haskell (-&gt;) from <code>GHC.Prim</code> we have:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Hask</span> <span class="fu">=</span> (<span class="ot">-&gt;</span>)

<span class="kw">class</span> <span class="dt">Cat</span> cat <span class="kw">where</span>
<span class="ot">    ident ::</span> cat a a
<span class="ot">    comp  ::</span> cat b c <span class="ot">-&gt;</span> cat a b <span class="ot">-&gt;</span> cat a c

<span class="kw">instance</span> <span class="dt">Cat</span> <span class="dt">Hask</span> <span class="kw">where</span>
    ident x  <span class="fu">=</span> x
    comp f g <span class="fu">=</span> \x <span class="ot">-&gt;</span> f (g x)</code></pre>
<p>We see that we of course recover the identitiy function and compostion from the Prelude.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Cat</span> <span class="dt">Hask</span> <span class="kw">where</span>
    ident <span class="fu">=</span> <span class="fu">id</span>
    comp  <span class="fu">=</span> (<span class="fu">.</span>)

<span class="co">-- Equivalent definition from Control.Category</span>

<span class="kw">instance</span> <span class="dt">Category</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span>
    <span class="fu">id</span> <span class="fu">=</span> Prelude.id
    (<span class="fu">.</span>) <span class="fu">=</span> (<span class="fu">Prelude..</span>)</code></pre>
<p>It is worth noting the common confusion that morphisms are not functions. It is the other way around, in the category SET functions are morphisms with objects as sets but this is a special case. In general morphisms are a pure abstraction which have structural similarity to functions.</p>
<h4 id="trivial-categories">Trivial Categories</h4>
<p>A <strong>subcategory</strong> is a category contained within another category which also satisfies the category construction. A more advanced example that will be discussed later is that monads with an operation called Kleisli composition forms a category that is of much interest to Haskell programmers.</p>
<p>There are also some simple categories, the simplest being the $ 0 $ category, which is the category with no objects and no morphisms.</p>
<table>
<th>
0
</th>
<tr>
    <td>
Objects
</td>
    <td> </td>
    <td> 
\[ \emptyset \]
</td>
</tr>

<tr>
    <td>
Morphisms
</td>
    <td> </td>
    <td> 
\[ \emptyset \]
</td>
</tr>

<tr>
    <td>
Composition
</td>
    <td> 
*
</td>
    <td> 
*
</td>
</tr>

<tr>
    <td>
Identities
</td>
    <td> 
\[ \text{For all } A \]
</td>
    <td> 
\[ \text{id}_A : A \rightarrow A \]
</td>
</tr>

</table>

<p>The category laws are vacuously true for this category.</p>
<p>A slightly more interesting ( only slightly!) is the $ 1 $ category.</p>
<table>
<th>
1
</th>
<tr>
    <td>
Objects
</td>
    <td> 
singleton set
</td>
    <td> 
\[ {X} \]
</td>
</tr>

<tr>
    <td>
Morphisms
</td>
    <td> </td>
    <td> 
\[ f : X \rightarrow X \]
</td>
</tr>

<tr>
    <td>
Composition
</td>
    <td> </td>
    <td> 
\[ (f . f) = \text{id}_X \]
</td>
</tr>

<tr>
    <td>
Identities
</td>
    <td> 
\[ \text{For all } A \]
</td>
    <td>
    
\[ 
        \text{id}_X : X \rightarrow X  \\
        \text{id}_X = \lambda x. X
    \]
</td>
</tr>

</table>

<p>Since the only morphism in the category is also the identity all the laws hold merely by substitution.</p>
<p>It is also trivially true that $ 0 $ is a subcategory of $ 1 $ , $ 1 $ is also a subcategory of itself.</p>
<h4 id="vector-spaces">Vector Spaces</h4>
<p>For the linear-algebra inclined, a space of vectors with linear mappings between vector spaces also forms a category with.</p>
<ol style="list-style-type: decimal">
<li>Vectors spaces as objects.</li>
<li>Linear mappings as morphisms.</li>
<li>A composition operation $ \circ $ composing linear mappings.</li>
<li>For each vector $ A $ there is an identity mapping $ \text{id}_A $.</li>
</ol>
<h4 id="infinity-and-categories-of-categories">Infinity and Categories of Categories</h4>
<p>In the original definition of category we did not mention that the objects or morphisms necessarily form a set. Instead we stated in the definition that we need only have a collection of objects and morphisms.</p>
<p>A category which has its morphisms and objects in a set is referred to as a <strong>small category</strong>. A category which does not is referred to as a <strong>large category</strong>.</p>
<p>This begs the question as to whether we can form the category of all categories. The answer to this is no, because of the implications of self-referential sets. See <a href="http://en.wikipedia.org/wiki/Russell's_paradox">Russell’s Paradox</a>.</p>
<p>It is however very illuminating to look at the category of all small categories called <strong>CAT</strong> which does indeed form a category with objects as categories and mappings called functors as morphisms between categories.</p>
        </div>
    </div>

    <!-- JS
    ================================================== -->
    <script src="http://code.jquery.com/jquery-1.7.1.min.js"></script>

<!-- End Document
================================================== -->
</body>
